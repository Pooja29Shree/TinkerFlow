<!DOCTYPE html>
<html lang="en">
<!--Change Gemini API key in line 399-->

<head>
    <meta charset="UTF-8">
    <title>TinkerFlow Code Editor</title>
    <link rel="stylesheet" href="codemirror.min.css">
    <link rel="stylesheet" href="xterm.css" />

    <!-- Light and dark themes -->
    <link rel="stylesheet" href="github-light-theme.css">
    <link rel="stylesheet" href="github-dark-theme.css">
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="style-light.css" id="themestyle">

    <style>
        @font-face {
            font-family: 'DroidSansMono';
            src: url('./DroidSansMono.ttf') format('truetype');
        }

        body,
        html {
            margin: 0;
            padding: 0;
            height: 100%;
        }

        .CodeMirror {
            height: 54vh;
            font-size: 16px;
            font-family: "DroidSansMono";
        }

        /* Draw faint vertical lines for each indent level */
        /* Indent guide styles */
        .cm-indent-guide {
            position: relative;
        }

        .cm-indent-guide::before {
            content: "";
            position: absolute;
            border-left: 1.5px solid rgba(150, 150, 150, 0.5);
            top: 0;
            bottom: 0;
            left: 0;
        }

        .CodeMirror .line-highlight-red {
            /* Critical errors */
            background-color: rgba(0, 136, 255, 0.2);
        }

        .CodeMirror .line-highlight-orange {
            /* Warnings */
            background-color: rgba(255, 204, 0, 0.2);
        }
    </style>
</head>

<body>

    <div class="container">
        <div id="left-panel">
            <span class="o1">
                <span class="options" id="filemanager" title="Files"><img src="files.svg"></span>
                <span class="options" style="margin-bottom:10px" id="learncoding" title="Learning materials" onclick="goback()"><img
                        src="learn.svg"></span>
            </span>
            <span>
            </span>
        </div>

        <div id="middle-panel">

            <div id="controls">
                <span id="control-panel">
                    <select id="language">
                        <option value="python">Python</option>
                        <option value="text/x-csrc">C</option>
                    </select>
                    <select id="theme">
                        <option value="github-light" selected>Light</option>
                        <option value="github-dark">Dark</option>
                    </select>
                    <select id="fontsize">
                        <option value="12px">12px</option>
                        <option value="14px">14px</option>
                        <option value="16px" selected>16px</option>
                        <option value="18px">18px</option>
                        <option value="20px">20px</option>
                    </select>
                </span>
                <span id="files">
                </span>
                <span id="action-buttons">
                    <button id="run" onclick="runCode()">&#9654;</button>
                    <button id="verifyCode">Verify code</button>
                    <button id="clearHighlights" onclick="clearHighlights()">Clear highlights</button>
                </span>
            </div>
            <textarea id="editor"></textarea>
            <div class="terminal-wrapper">
                <div id="terminal"></div>
            </div>

        </div>

        <div id="right-panel">
            <span id="question"></span>
            <span id="voice" style="padding-bottom:20px; margin-right:20px; border-bottom:2px solid #2d3748; ">
                <center><span class="title">Ask your mentor</span></center><br>
                <center><img src="mic-on.svg" id="mic" alt="Mic" /></center> <br>
                <span class="subtitle">Ask your personal assistant for any clarifications regarding the question, the
                    code, the code editor, or any doubts you come across while learning!</span>
            </span>
            <span id="chat" style="overflow-y: auto;">
                <span class="gemini">Hello! How can I help you today?</span>
            </span>
            <span class="queryInput">
                <input type="text" id="query" placeholder="Ask your mentor..." />
                <button id="sendQuery">➤</button>
            </span>

        </div>
    </div>
    <div class="filemanager" id="filemanager-panel">
        <span class="title">File Manager</span>
        <p>Click on a file to open it in the editor. You can close files by clicking the '&#10005;' button next to them.
            Click anywhere to close this window.</p>
        <div id="file-list">
        </div>
    </div>
</body>
<!-- Core CodeMirror -->
<script src="codemirror.min.js"></script>

<!-- Modes -->
<script src="python.min.js"></script>
<script src="clike.min.js"></script>

<!-- Addons -->
<script src="active-line.min.js"></script>
<script src="matchbrackets.min.js"></script>
<script src="closebrackets.min.js"></script>
<script src="rulers.min.js"></script>
<script src="overlay.min.js"></script>

<!--Terminal-->
<script src="xterm.js"></script>
<script src="xterm-addon-fit.js"></script>

<script>
    /* Indent guides */
    CodeMirror.defineMode("indentGuides", function (config, parserConfig) {
        var baseMode = CodeMirror.getMode(config, parserConfig.backdrop || config.mode);
        var indentUnit = config.indentUnit || 4;

        // Helper function to get line indentation level
        function getIndentLevel(line) {
            if (!line) return 0;
            var indentChars = 0;
            for (var i = 0; i < line.length && (line[i] === ' ' || line[i] === '\t'); i++) {
                if (line[i] === '\t') {
                    indentChars += indentUnit;
                } else {
                    indentChars++;
                }
            }
            return Math.floor(indentChars / indentUnit);
        }

        // Helper function to check if a line is effectively empty
        function isEmptyLine(line) {
            return !line || /^\s*$/.test(line);
        }

        return {
            startState: function () {
                return {
                    baseState: CodeMirror.startState(baseMode),
                    indentGuideState: {
                        indentLevel: 0,
                        currentLevel: 0,
                        inIndentArea: false,
                        isEmptyLine: false
                    }
                };
            },

            token: function (stream, state) {
                var indentState = state.indentGuideState;

                // At start of line, analyze indentation
                if (stream.sol()) {
                    var line = stream.string;
                    var actualIndentChars = 0;
                    var i = 0;

                    // Count leading whitespace on current line
                    while (i < line.length && (line[i] === ' ' || line[i] === '\t')) {
                        if (line[i] === '\t') {
                            actualIndentChars += indentUnit;
                        } else {
                            actualIndentChars++;
                        }
                        i++;
                    }

                    var actualIndentLevel = Math.floor(actualIndentChars / indentUnit);
                    indentState.isEmptyLine = isEmptyLine(line);

                    // For non-empty lines, use actual indentation
                    // For empty lines, don't draw any guides (simpler approach)
                    if (indentState.isEmptyLine) {
                        indentState.inIndentArea = indentState.indentLevel > 0;
                    } else {
                        indentState.indentLevel = actualIndentLevel;
                        indentState.inIndentArea = actualIndentChars > 0;
                    }

                    indentState.currentLevel = 0;
                    indentState.nonWhitespacePos = i;
                }

                // Handle indent guides in the indentation area
                if (indentState.inIndentArea && stream.pos < indentState.nonWhitespacePos) {
                    if (indentState.currentLevel < indentState.indentLevel) {
                        var startPos = stream.pos;

                        // For tabs, consume one tab
                        if (stream.peek() === '\t') {
                            stream.next();
                            indentState.currentLevel++;
                            return "indent-guide indent-guide-" + indentState.currentLevel;
                        }

                        // For spaces, consume until next indent boundary
                        var targetPos = Math.min(indentState.currentLevel * indentUnit + indentUnit, indentState.nonWhitespacePos);
                        while (stream.pos < targetPos && stream.pos < indentState.nonWhitespacePos) {
                            stream.next();
                        }

                        if (stream.pos > startPos) {
                            indentState.currentLevel++;
                            return "indent-guide indent-guide-" + indentState.currentLevel;
                        }
                    }

                    // Consume remaining whitespace without indent guide
                    while (stream.pos < indentState.nonWhitespacePos && !stream.eol()) {
                        stream.next();
                    }
                    return null;
                }

                // Let the base mode handle everything else
                return baseMode.token(stream, state.baseState);
            },

            blankLine: function (state) {
                if (baseMode.blankLine) {
                    return baseMode.blankLine(state.baseState);
                }
            },

            electricChars: baseMode.electricChars,
            electricInput: baseMode.electricInput,

            copyState: function (state) {
                return {
                    baseState: CodeMirror.copyState(baseMode, state.baseState),
                    indentGuideState: {
                        indentLevel: state.indentGuideState.indentLevel,
                        currentLevel: state.indentGuideState.currentLevel,
                        inIndentArea: state.indentGuideState.inIndentArea,
                        isEmptyLine: state.indentGuideState.isEmptyLine
                    }
                };
            },

            indent: function (state, textAfter) {
                var indentState = state.indentGuideState;
                var baseIndent = CodeMirror.Pass;

                if (baseMode.indent) {
                    baseIndent = baseMode.indent(state.baseState, textAfter);
                }

                // If base mode gave us Pass, just use the guide level
                if (baseIndent === CodeMirror.Pass) {
                    return indentState.indentLevel * indentUnit;
                }

                // Otherwise, clamp it so nested blocks don’t double-indent
                var maxAllowed = (indentState.indentLevel + 1) * (indentUnit);

                return Math.min(baseIndent, maxAllowed);
            }

        };
    });
    /* End of indent guides mode definition */

    // Init editor
    var editor = CodeMirror.fromTextArea(document.getElementById("editor"), {
        lineNumbers: true,
        mode: { name: "indentGuides", backdrop: "python" },
        theme: "github-light",
        matchBrackets: true,
        autoCloseBrackets: true,
        indentUnit: 4,
        tabSize: 4,
        styleActiveLine: true,
        lineWrapping: false
    });

    const termLightTheme = {
        background: "#f5f5f5",        // keeping your original background
        foreground: "#2c3e50",        // darker, more readable main text
        cursor: "#2c3e50",            // bright blue cursor for visibility
        cursorAccent: "#f5f5f5",      // cursor text color
        selectionBackground: "#bdc3c7", // softer selection highlight
        selectionForeground: "#2c3e50", // dark text on selection

        // Standard colors - optimized for light background
        black: "#2c3e50",             // dark blue-gray instead of pure black
        red: "#e74c3c",               // vibrant red
        green: "#27ae60",             // forest green
        yellow: "#f39c12",            // warm orange-yellow
        blue: "#3498db",              // bright blue
        magenta: "#9b59b6",           // purple
        cyan: "#1abc9c",              // teal
        white: "#95a5a6",             // medium gray

        // Bright colors - more vivid versions
        brightBlack: "#7f8c8d",       // lighter gray
        brightRed: "#c0392b",         // darker red
        brightGreen: "#2ecc71",       // bright green
        brightYellow: "#e67e22",      // orange
        brightBlue: "#2980b9",        // darker blue
        brightMagenta: "#8e44ad",     // darker purple
        brightCyan: "#16a085",        // darker teal
        brightWhite: "#34495e",       // dark gray for contrast
    }

    const termDarkTheme = {
        background: "#141a23",        // dark blue-gray background
        foreground: "#e1e8f0",        // light gray-blue for main text
        cursor: "#e1e8f0",            // bright cyan cursor for visibility
        cursorAccent: "#141a23",      // dark cursor text color
        selectionBackground: "#2d3748", // subtle selection highlight
        selectionForeground: "#e1e8f0", // light text on selection

        // Standard colors - optimized for dark background
        black: "#1a202c",             // very dark gray
        red: "#ff6b6b",               // coral red
        green: "#4ecdc4",             // mint green
        yellow: "#ffe66d",            // warm yellow
        blue: "#74b9ff",              // sky blue
        magenta: "#a29bfe",           // lavender
        cyan: "#64ffda",              // bright cyan
        white: "#cbd5e0",             // light gray

        // Bright colors - more vivid versions for dark theme
        brightBlack: "#4a5568",       // medium gray
        brightRed: "#ff5252",         // bright red
        brightGreen: "#00e676",       // electric green
        brightYellow: "#ffd740",      // golden yellow
        brightBlue: "#448aff",        // electric blue
        brightMagenta: "#e040fb",     // bright magenta
        brightCyan: "#18ffff",        // electric cyan
        brightWhite: "#f7fafc",       // almost white
    }

    const term = new Terminal({
        cursorBlink: true,
        fontSize: 16,
        theme: termLightTheme
    });
    const fitAddon = new FitAddon.FitAddon();
    term.loadAddon(fitAddon);
    term.open(document.getElementById("terminal"));
    setTimeout(() => fitAddon.fit(), 0);

    // re-fit when window resizes
    window.addEventListener("resize", () => fitAddon.fit());

    const socket = new WebSocket("ws://localhost:3000");
    socket.onmessage = e => term.write(e.data);
    term.onData(data => socket.send(data));

    // Language switch
    document.getElementById("language").addEventListener("change", function () {
        editor.setOption("mode", this.value);
    });

    // Theme switch
    document.getElementById("theme").addEventListener("change", function () {
        editor.setOption("theme", this.value);
        if (this.value === "github-dark") {
            document.getElementById("themestyle").setAttribute("href", "style-dark.css");
            term.options.theme = termDarkTheme;
        } else {
            document.getElementById("themestyle").setAttribute("href", "style-light.css");
            term.options.theme = termLightTheme;
        }
    });

    // Font size switch
    document.getElementById("fontsize").addEventListener("change", function () {
        editor.getWrapperElement().style.fontSize = this.value;
        editor.refresh();

        term.options.fontSize = parseInt(this.value);
        fitAddon.fit();

    });

    redlines = []
    orangelines = []

    redlines.forEach(function (line) {
        editor.addLineClass(line - 1, "background", "line-highlight-red");
    });

    orangelines.forEach(function (line) {
        editor.addLineClass(line - 1, "background", "line-highlight-orange");
    });

    function line_highlight_red(line_numbers) {
        if (Array.isArray(line_numbers)) {
            redlines = line_numbers;
        }
        redlines.forEach(function (line) {
            editor.addLineClass(line - 1, "background", "line-highlight-red");
        });
    }

    function line_highlight_orange(line_numbers) {
        if (Array.isArray(line_numbers)) {
            orangelines = line_numbers;
        }
        orangelines.forEach(function (line) {
            editor.addLineClass(line - 1, "background", "line-highlight-orange");
        });
    }

    function clearHighlights() {
        redlines.forEach(function (line) {
            editor.removeLineClass(line - 1, "background", "line-highlight-red");
        });
        orangelines.forEach(function (line) {
            editor.removeLineClass(line - 1, "background", "line-highlight-orange");
        });
        redlines = [];
        orangelines = [];
    }

    function runCode() {
        const activeFileElem = document.querySelector(".file-name.selected-file .openedfile");
        console.log(activeFileElem);
        if (!activeFileElem) {
            alert("Please open a file to work with.")
            return;
        }
        // File is already there in PWD, so run with python3 filename
        const fileName = activeFileElem.textContent;
        const command = (fileName.endsWith(".py") ? "python3 " : fileName.endsWith(".c") ? "gcc " : "") + fileName + (fileName.endsWith(".c") ? " -o " + fileName.slice(0, -2) + " && ./" + fileName.slice(0, -2) : "") + "\n";
        socket.send(command);
    }

    /* Gemini API integration */
    let API_KEY = "";
    fetch("api-key.txt")
        .then(response => response.text())
        .then(key => {
            API_KEY = key.trim();
        })
        .catch(error => {
            console.error("Could not load API key:", error);
        });

    // Create model with a fixed system instruction (context)
    async function initModel(context) {
        return {
            model: "gemini-2.5-flash",
            systemInstruction: {
                role: "user",
                parts: [{ text: context }]
            }
        };
    }

    let modelConfig = null;

    // Set context once
    async function setGeminiRules() {
        const context = await fetch("context.txt").then(r => r.text());
        modelConfig = await initModel(context);
    }
    setGeminiRules();  // initializes modelConfig right away

    // Verify code using that context
    function showLoading() {
        document.body.classList.add('loading');
        document.querySelector(".container").style.opacity = "0.4";
        // Or create/show your loading element
        const loader = document.createElement('div');
        loader.id = 'loader';
        loader.innerHTML = '<div class="spinner"></div>';
        document.body.appendChild(loader);
    }

    function hideLoading() {
        document.body.classList.remove('loading');
        document.querySelector(".container").style.opacity = "1";
        const loader = document.getElementById('loader');
        if (loader) loader.remove();
    }

    async function askGemini(prompt) {
        prompt = "User query:\n" + prompt + "\n\nCurrent code:\n" + editor.getValue() + "\n\nQuestion:\n" + document.getElementById("question").getElementsByClassName("displayQN")[0].textContent;
        showLoading();
        document.querySelector(".container").style.opacity = "0.3";
        const response = await fetch(
            `https://generativelanguage.googleapis.com/v1beta/models/${modelConfig.model}:generateContent?key=${API_KEY}`,
            {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    systemInstruction: modelConfig.systemInstruction, // context set once
                    contents: [{ parts: [{ text: prompt }] }]
                })
            }
        );


        console.log("Waiting for Gemini response...");
        const data = await response.json();
        document.querySelector(".container").style.opacity = "1";
        hideLoading();
        let result = data.candidates[0].content.parts[0].text;
        if (result.startsWith("```json")) {
            result = result.replace(/^```json\s*/, "").replace(/```$/, "");
        } else if (result.startsWith("{")) {
            // result is already JSON
        } else {
            result = '{"text":"error on Gemini API side"}';
        }
        const parsedResult = JSON.parse(result);
        const gemSpan = document.createElement("span");
        gemSpan.className = "gemini";
        gemSpan.innerHTML = parsedResult.text;
        document.getElementById("chat").appendChild(gemSpan);
        document.getElementById("chat").scrollTop = document.getElementById("chat").scrollHeight;

        if (parsedResult.calls && Array.isArray(parsedResult.calls)) { parsedResult.calls.forEach(call => { eval(call); }); }

    }
    function runInTerminal(command) {
        socket.send(command + "\n");
    }
    function writeToEditor(newCode) {
        editor.setValue(newCode);
    }
    /* End of Gemini API integration */
    document.getElementById("verifyCode").addEventListener("click", () => {
        const prompt = "Verify the code, but do not provide corrected code or run the code. Highlight the lines, and explain the errors and suggestions.";
        askGemini(prompt)
    }); // Verify code on button click
    document.getElementById("sendQuery").addEventListener("click", function () {
        const userQuery = document.getElementById("query").value;
        if (userQuery.trim() === "") return;
        const userSpan = document.createElement("span");
        userSpan.className = "user";
        userSpan.textContent = userQuery;
        document.getElementById("chat").appendChild(userSpan);
        document.getElementById("chat").scrollTop = document.getElementById("chat").scrollHeight;
        document.getElementById("query").value = "";
        askGemini(userQuery);
    });

    document.getElementById("query").addEventListener("keypress", function (e) {
        if (e.key === "Enter") {
            document.getElementById("sendQuery").click();
        }
    });


    /* Question management */
    let questions = [];
    let currentQuestionIndex = 0;

    function loadQuestionsFromJson(questionFile) {
        fetch(questionFile)
            .then(response => response.json())
            .then(data => {
                // Convert object to array of {key, value}
                questions = Object.entries(data).map(([key, value]) => ({ key, value }));
                currentQuestionIndex = 0;
                displayCurrentQuestion(questionFile);
            })
            .catch(error => console.error('Error loading questions:', error));
    }

    function displayCurrentQuestion(questionFile) {
        const questionSpan = document.getElementById('question');
        if (questions.length === 0) {
            questionSpan.innerHTML = "No questions available.";
            return;
        }
        const q = questions[currentQuestionIndex];
        questionSpan.innerHTML = `
            <span class="navMenu">
                <b style="font-size:22px;">${questionFile.slice(0, -5)}</b>
                <span>
                    <button id="prevQuestion" ${currentQuestionIndex === 0 ? "disabled" : ""} style="margin-left:20px;">&larr; Previous</button>
                    <button id="nextQuestion" ${currentQuestionIndex === questions.length - 1 ? "disabled" : ""} style="margin-left:10px;">Next &rarr;</button>
                </span>
            </span>
            
            <b>Question ${q.key}:</b> <span class="displayQN">${q.value}</span><br><br>
            `;

        document.getElementById("prevQuestion").onclick = function () {
            if (currentQuestionIndex > 0) {
                currentQuestionIndex--;
                displayCurrentQuestion(questionFile);
            }
        };
        document.getElementById("nextQuestion").onclick = function () {
            if (currentQuestionIndex < questions.length - 1) {
                currentQuestionIndex++;
                displayCurrentQuestion(questionFile);
            }
        };
    }
    /* End of question management */

    // Yet to implement
    filemanager, learncoding = document.getElementById("filemanager"), document.getElementById("learncoding")
    function goback(){
        window.history.back()
    }

    // Toggle file manager panel and blur background, disable interactions
    document.getElementById("filemanager").addEventListener("click", function () {
        const panel = document.getElementById("filemanager-panel");
        const container = document.querySelector(".container");
        const isVisible = panel.style.display === "block";
        panel.style.display = isVisible ? "none" : "block";

        if (!isVisible) {
            container.style.opacity = "0.3";
            container.style.pointerEvents = "none";
            panel.style.pointerEvents = "auto";
        }
    });

    // Hide filemanager panel and remove blur/disable when clicking outside
    document.addEventListener("mousedown", function (e) {
        const panel = document.getElementById("filemanager-panel");
        const container = document.querySelector(".container");
        if (panel.style.display === "block" && !panel.contains(e.target)) {
            panel.style.display = "none";
            container.style.filter = "";
            container.style.opacity = "";
            container.style.pointerEvents = "";
        }
    });

    // Load file content into editor
    function loadFileContent(fileName) {
        fetch(fileName)
            .then(response => {
                if (!response.ok) {
                    throw new Error('Network response was not ok ' + response.statusText);
                }
                return response.text();
            })
            .then(data => {
                editor.setValue(data);
            })
            .catch(error => {
                console.error('Error loading file:', error);
                editor.setValue(`Could not load file: ${fileName}\n`);
            });
    }

    let availableFiles = [];
    let availableFileElements = [];
    let openFiles = [];

    // Fetch files and populate UI
    async function loadFiles() {
        try {
            const response = await fetch('/list-files');
            const files = await response.json();
            availableFiles = files.filter(f => f.endsWith('.py') || f.endsWith('.c'));
            updateFileList();
            return availableFiles;  // return the files
        } catch (err) {
            console.error('Error fetching file list:', err);
            return [];  // fail gracefully
        }
    }
    function cleanText(text) {
        return text
            // Remove anything not A-Z, a-z, 0-9, dot, underscore, or dash
            .replace(/[^A-Za-z0-9._-]/g, "")
            // Trim any leftover whitespace
            .trim();
    }

    function updateEditorState() {
        if (openFiles.length === 0) {
            editor.setOption("mode", "text/x-csrc");
            document.getElementById("language").value = "text/x-csrc";
        }
    }
    updateEditorState();

    function updateFileList() {
        const fileListDiv = document.getElementById("file-list");
        if (!fileListDiv) return;
        fileListDiv.innerHTML = "";            // Clear existing list
        availableFileElements = [];            // Reset elements array

        availableFiles.forEach(file => {
            const fileSpan = document.createElement("span");
            fileSpan.className = "file-item";
            fileSpan.textContent = file;
            fileListDiv.appendChild(fileSpan);
            availableFileElements.push(fileSpan);

            // Attach click handler here (after element exists)
            fileSpan.addEventListener("click", function () {
                // Hide file manager and restore main container
                const panel = document.getElementById("filemanager-panel");
                const container = document.querySelector(".container");
                if (panel) panel.style.display = "none";
                if (container) {
                    container.style.filter = "";
                    container.style.opacity = "";
                    container.style.pointerEvents = "";
                }

                const fileName = file;
                console.log(`Opening file: ${fileName}`);
                if (!openFiles.includes(fileName)) {
                    openFiles.push(fileName);

                    const tab = document.createElement("span");
                    tab.className = "file-name";

                    // Deselect other tabs and select this one
                    document.querySelectorAll(".file-name").forEach(fn => fn.classList.remove("selected-file"));
                    tab.classList.add("selected-file");

                    tab.innerHTML = `<span class="openedfile">${fileName}</span>
                                 <button class="closefile" title="Close file">&#10005;</button>`;
                    document.getElementById("files").appendChild(tab);

                    // Load file content into editor and set mode
                    loadFileContent(fileName);
                    if (fileName.endsWith(".py")) {
                        editor.setOption("mode", "python");
                        document.getElementById("language").value = "python";
                    } else if (fileName.endsWith(".c")) {
                        editor.setOption("mode", "text/x-csrc");
                        document.getElementById("language").value = "text/x-csrc";
                    } else {
                        editor.setOption("mode", "text/plain");
                    }

                    // Click to switch to this open tab
                    tab.querySelector(".openedfile").addEventListener("click", function () {
                        document.querySelectorAll(".file-name").forEach(fn => fn.classList.remove("selected-file"));
                        tab.classList.add("selected-file");
                        loadFileContent(fileName);
                        if (fileName.endsWith(".py")) {
                            editor.setOption("mode", "python");
                            document.getElementById("language").value = "python";
                        } else if (fileName.endsWith(".c")) {
                            editor.setOption("mode", "text/x-csrc");
                            document.getElementById("language").value = "text/x-csrc";
                        } else {
                            editor.setOption("mode", "text/plain");
                        }
                        updateEditorState();
                    });

                    // Close tab
                    tab.querySelector(".closefile").addEventListener("click", function (e) {
                        e.stopPropagation();
                        const idx = openFiles.indexOf(fileName);
                        if (idx > -1) openFiles.splice(idx, 1);
                        tab.remove();

                        if (tab.classList.contains("selected-file") && openFiles.length > 0) {
                            const lastFile = openFiles[openFiles.length - 1];
                            document.querySelectorAll(".file-name").forEach(fn => fn.classList.remove("selected-file"));
                            const lastFileElem = Array.from(document.getElementsByClassName("file-name"))
                                .find(fn => fn.textContent.includes(lastFile));
                            if (lastFileElem) {
                                lastFileElem.classList.add("selected-file");
                                let clean = cleanText(lastFileElem.textContent)
                                loadFileContent(lastFile);
                                if (clean.endsWith(".py")) {
                                    editor.setOption("mode", "python");
                                    document.getElementById("language").value = "python";
                                } else if (clean.endsWith(".c")) {
                                    editor.setOption("mode", "text/x-csrc");
                                    document.getElementById("language").value = "text/x-csrc";
                                } else {
                                    editor.setOption("mode", "text/plain");
                                }
                            }
                        }
                        updateEditorState();
                    });
                } else {
                    // already open -> select it
                    document.querySelectorAll(".file-name").forEach(fn => fn.classList.remove("selected-file"));
                    const existingFileElem = Array.from(document.getElementsByClassName("file-name"))
                        .find(fn => fn.textContent.includes(fileName));
                    if (existingFileElem) {
                        existingFileElem.classList.add("selected-file");
                        let clean = cleanText(existingFileElem.textContent)
                        loadFileContent(clean);
                        if (clean.endsWith(".py")) {
                            editor.setOption("mode", "python");
                            document.getElementById("language").value = "python";
                        } else if (clean.endsWith(".c")) {
                            editor.setOption("mode", "text/x-csrc");
                            document.getElementById("language").value = "text/x-csrc";
                        } else {
                            editor.setOption("mode", "text/plain");
                        }
                    }
                }
                updateEditorState();
            });
        });

    }

    // start loading files
    loadFiles();

    // Initialize with a file - Change to actual file which is being opened
    // availableFileElements[0].click(); // Modify to open specified file

    let saveTimeout;

    editor.on("change", function () {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(() => {
            const selectedFileElem = document.querySelector(".file-name.selected-file .openedfile");
            if (selectedFileElem) {
                const fileName = selectedFileElem.textContent;
                const fileContent = editor.getValue();
                console.log(`Auto-saving ${fileName}`);
                fetch(`/save?filename=${encodeURIComponent(fileName)}`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ content: fileContent })
                }).then(r => r.text())
                    .then(data => console.log(`Auto-saved ${fileName} successfully.`))
                    .catch(err => console.error("Error auto-saving file:", err));
            } // If no file is opened, then nothing will happen
        }, 500); // save 0.5s after last change
    });

    async function openFileByName(fileName) {
        const availableFiles = await loadFiles();
        if (files.length === 0) {
            console.log("No matching files found");
        } else {
            if (availableFiles.includes(fileName)) {
                const fileToOpen = Array.from(document.getElementsByClassName("file-item")).find(fn => fn.textContent.includes(fileName))
                if (fileToOpen) {
                    fileToOpen.click();
                }
            }
        }
    }

    const micBtn = document.getElementById("mic");
    let isRecording = false;
    let mediaRecorder = null;
    let audioChunks = [];

    const ASSEMBLYAI_API_KEY = "e07423c4d6494f4b82e1509a4e61f9cf";

    micBtn.addEventListener("click", function () {
        const queryInput = document.getElementById("query");
        const sendQueryBtn = document.getElementById("sendQuery");
        if (isRecording) { // Stop recording
            micBtn.src = "mic-on.svg";
            queryInput.disabled = false;
            sendQueryBtn.disabled = false;
            handleListenRelease();
        } else {  // Start recording
            micBtn.src = "mic-off.svg";
            queryInput.disabled = true;
            sendQueryBtn.disabled = true;
            handleListenPress();
        }
        isRecording = !isRecording;
    });

    async function handleListenPress() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);

            audioChunks = [];
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) audioChunks.push(event.data);
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                audioChunks = [];
                // Stop mic stream
                stream.getTracks().forEach(track => track.stop());
                await sendAudioToAssemblyAI(audioBlob);
            };

            mediaRecorder.start();
        } catch (error) {
            console.error("Error accessing microphone:", error);
            alert("Could not access microphone. Please check permissions.");
        }
    }

    function handleListenRelease() {
        if (mediaRecorder && mediaRecorder.state !== "inactive") {
            mediaRecorder.stop();
        }
    }

    async function sendAudioToAssemblyAI(audioBlob) {
        const queryInput = document.getElementById("query");
        const sendQueryBtn = document.getElementById("sendQuery");

        queryInput.value = "Transcribing...";
        showLoading();
        try {
            // Upload audio
            const uploadResponse = await fetch('https://api.assemblyai.com/v2/upload', {
                method: 'POST',
                headers: {
                    'authorization': ASSEMBLYAI_API_KEY,
                    'content-type': 'application/octet-stream'
                },
                body: audioBlob
            });
            const uploadData = await uploadResponse.json();
            const audioUrl = uploadData.upload_url;

            // Request transcript
            const transcriptResponse = await fetch('https://api.assemblyai.com/v2/transcript', {
                method: 'POST',
                headers: {
                    'authorization': ASSEMBLYAI_API_KEY,
                    'content-type': 'application/json'
                },
                body: JSON.stringify({ audio_url: audioUrl })
            });
            const transcriptData = await transcriptResponse.json();
            const transcriptId = transcriptData.id;

            // Poll until ready
            while (true) {
                const pollResponse = await fetch(`https://api.assemblyai.com/v2/transcript/${transcriptId}`, {
                    headers: { 'authorization': ASSEMBLYAI_API_KEY }
                });
                const pollData = await pollResponse.json();

                if (pollData.status === 'completed') {
                    queryInput.value = pollData.text;
                    sendQueryBtn.click();
                    break;
                } else if (pollData.status === 'failed') {
                    throw new Error("Transcription failed.");
                }
                await new Promise(resolve => setTimeout(resolve, 2000));
            }

        } catch (error) {
            console.error("Error with AssemblyAI:", error);
            queryInput.value = "Speech-to-text failed. Please try again.";
        } finally {
            hideLoading();
        }
    }

    // Change these functions to open custom file
    loadQuestionsFromJson('Level 1.json'); // Load questions from level1.json on page load
    openFileByName("level-1.py");
</script>

</html>